#!/usr/bin/env bash
#
# linux_ultimate_tuner.sh
#
# A comprehensive, single-file system optimization suite for modern Linux distributions.
# Target audience: power users, developers, gamers, and sysadmins who want a safe,
# reversible, and modular set of performance and reliability improvements.
#
# IMPORTANT:
# - Run as root (script checks and exits otherwise).
# - The script is interactive: destructive actions require explicit confirmation.
# - Every change to a system file creates a timestamped backup before modification.
# - The script is modular; you can run individual functions from the menu.
#
# NOTE: This script aims to be portable across mainstream distros (Debian/Ubuntu, Fedora,
# Arch, OpenSUSE). It detects environment characteristics (virtualization, laptop vs desktop,
# CPU arch, filesystem) and adapts behavior accordingly.
#
# Author: Generated by ChatGPT (GPT-5 Thinking mini)
# Date: 2025-08-29
#

# ---------------------------
# Basic safety & environment
# ---------------------------

set -euo pipefail
IFS=$'\n\t'

SCRIPT_NAME="$(basename "$0")"
TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
BACKUP_DIR="/var/backups/ultimate-tuner"
mkdir -p "$BACKUP_DIR"

# Ensure running as root
if [ "$(id -u)" -ne 0 ]; then
  cat >&2 <<EOF
ERROR: This script must be run as root.
Usage: sudo ./$SCRIPT_NAME
Exiting.
EOF
  exit 1
fi

# Helper: confirm prompt (yes/no). Default is no.
confirm() {
  # Usage: confirm "message"
  local msg="${1:-Are you sure?}"
  local ans
  while true; do
    printf "%s [y/N]: " "$msg"
    read -r ans
    case "$ans" in
      [Yy]|[Yy][Ee][Ss]) return 0 ;;
      [Nn]|""|[Nn][Oo]) return 1 ;;
      *) echo "Please answer y or n." ;;
    esac
  done
}

# Helper: timestamped backup of a file before modification
backup_file() {
  # Usage: backup_file /path/to/file
  local file="$1"
  if [ -e "$file" ]; then
    local bn
    bn="$(basename "$file")"
    local dest="$BACKUP_DIR/${bn}.backup.$TIMESTAMP"
    cp -a "$file" "$dest"
    echo "Backed up $file -> $dest"
  fi
}

# Helper: safe write file with backup (creates parent dirs)
safe_write_file() {
  # Usage: safe_write_file /path/to/file "content..."
  local file="$1"
  local content="$2"
  mkdir -p "$(dirname "$file")"
  backup_file "$file"
  printf '%s\n' "$content" > "$file"
  echo "Wrote $file (backup created if present)."
}

log() {
  printf '[%s] %s\n' "$(date +'%F %T')" "$*"
}

# Detect distribution & package manager
detect_distro() {
  DISTRO=""
  PKG=""
  if [ -f /etc/os-release ]; then
    . /etc/os-release
    DISTRO="${ID:-$DISTRO}"
    DISTRO_LIKE="${ID_LIKE:-}"
  fi

  if command -v apt >/dev/null 2>&1; then
    PKG="apt"
  elif command -v dnf >/dev/null 2>&1; then
    PKG="dnf"
  elif command -v yum >/dev/null 2>&1; then
    PKG="yum"
  elif command -v pacman >/dev/null 2>&1; then
    PKG="pacman"
  elif command -v zypper >/dev/null 2>&1; then
    PKG="zypper"
  else
    PKG="unknown"
  fi
}

# Detect virtualization using systemd-detect-virt (fallbacks)
detect_virtualization() {
  VIRT="none"
  if command -v systemd-detect-virt >/dev/null 2>&1; then
    VIRT="$(systemd-detect-virt -v || true)"
    # systemd-detect-virt returns the type or "none"
    [ -z "$VIRT" ] && VIRT="unknown"
  else
    # fallback: look at dmi
    if command -v dmidecode >/dev/null 2>&1; then
      if dmidecode -s system-product-name 2>/dev/null | grep -qi virtual; then
        VIRT="vm"
      fi
    fi
  fi
}

# Detect if laptop (battery present)
detect_form_factor() {
  IS_LAPTOP=0
  if [ -d /sys/class/power_supply ] && ls /sys/class/power_supply/* 2>/dev/null | grep -q . ; then
    # presence of power_supply devices indicates laptop/UPS etc.
    for p in /sys/class/power_supply/*; do
      if [ -f "$p/type" ] && grep -qi "Battery" "$p/type" 2>/dev/null; then
        IS_LAPTOP=1
        break
      fi
      # older kernels may have 'Battery' or 'battery'
      if [ -f "$p"/uevent ] && grep -qi "POWER_SUPPLY_TYPE=battery" "$p"/uevent 2>/dev/null; then
        IS_LAPTOP=1
        break
      fi
    done
  fi
}

# Detect CPU architecture and flags
detect_cpu() {
  ARCH="$(uname -m)"
  CPU_FLAGS=""
  if [ -r /proc/cpuinfo ]; then
    CPU_FLAGS="$(awk -F: '/flags|Features/ { $1=""; print $0 }' /proc/cpuinfo | tr '[:upper:]' '[:lower:]' | head -n1 || true)"
  fi
}

# Detect root filesystem type
detect_root_fs() {
  ROOT_FS=""
  ROOT_DEV="$(findmnt -n -o SOURCE / 2>/dev/null || true)"
  if [ -n "$ROOT_DEV" ]; then
    ROOT_FS="$(findmnt -n -o FSTYPE / 2>/dev/null || true)"
  fi
  # fallback: parse /etc/mtab
  if [ -z "$ROOT_FS" ]; then
    ROOT_FS="$(stat -f -c %T / 2>/dev/null || true)"
  fi
}

# Detect primary block device (first non-loop, non-ram)
detect_primary_block() {
  PRIMARY_BLOCK=""
  # prefer root device mapping
  if [ -n "$ROOT_DEV" ]; then
    # remove /dev/mapper/ or UUID= etc
    if echo "$ROOT_DEV" | grep -qL "^/dev/"; then
      # attempt to resolve
      ROOT_DEV_PATH="$(readlink -f "/dev/disk/by-uuid/${ROOT_DEV#UUID=}" 2>/dev/null || true)"
      [ -n "$ROOT_DEV_PATH" ] && ROOT_DEV="$ROOT_DEV_PATH"
    fi
    PRIMARY_BLOCK="$(lsblk -no PKNAME "$ROOT_DEV" 2>/dev/null || true)"
    if [ -z "$PRIMARY_BLOCK" ]; then
      # try to use the device name directly
      PRIMARY_BLOCK="$(basename "$ROOT_DEV" 2>/dev/null || true)"
    fi
  fi

  # fallback: pick first non-loop block device
  if [ -z "$PRIMARY_BLOCK" ]; then
    for b in /sys/block/*; do
      bn="$(basename "$b")"
      if [ -e "/sys/block/$bn/loop" ]; then
        continue
      fi
      # skip ram
      if echo "$bn" | grep -qE '^ram|loop'; then
        continue
      fi
      PRIMARY_BLOCK="$bn"
      break
    done
  fi
}

# Run detection on startup
detect_all() {
  detect_distro
  detect_virtualization
  detect_form_factor
  detect_cpu
  detect_root_fs
  detect_primary_block

  log "Detected distro: $DISTRO (pkg: $PKG)"
  log "Virtualization: $VIRT"
  log "Is laptop: $IS_LAPTOP"
  log "ARCH: $ARCH"
  log "CPU flags snippet: ${CPU_FLAGS:0:120}..."
  log "Root FS: $ROOT_FS, Root device: $ROOT_DEV, Primary block: $PRIMARY_BLOCK"
}

# ---------------------------
# Package install helper
# ---------------------------

pkg_install() {
  # Usage: pkg_install package1 package2 ...
  local pkgs="$*"
  case "$PKG" in
    apt)
      apt update -y
      DEBIAN_FRONTEND=noninteractive apt install -y $pkgs
      ;;
    dnf)
      dnf install -y $pkgs
      ;;
    yum)
      yum install -y $pkgs
      ;;
    pacman)
      pacman -Sy --noconfirm $pkgs
      ;;
    zypper)
      zypper --non-interactive install $pkgs
      ;;
    unknown)
      echo "Unknown package manager. Please install: $pkgs manually."
      return 2
      ;;
  esac
}

# ---------------------------
# 1) Aggressive Disk Cleaning & I/O Optimization
# ---------------------------

# Explanation block:
# What: clean_disk_io runs package cache cleaning, user cache cleanup, journallog pruning,
#       and suggests fstab mount options for SSDs. It also tunes I/O scheduler for the primary disk.
# Why: reduces disk usage, removes cruft, and sets appropriate I/O scheduler for better responsiveness.
# Risk: removing packages/kernels or aggressive pruning may delete needed files. Changes to scheduler
#       are transient and will revert on reboot unless persisted. Do not auto-modify fstab — only suggest.
# Revert: Backups are made before any file edits. Journal vacuum is irreversible but only removes old logs.
#         Removed packages may be reinstalled via package manager. Scheduler reverts on reboot.

clean_package_caches() {
  # Clean package manager caches and orphaned packages where applicable.
  log "=== clean_package_caches ==="
  echo "Detected package manager: $PKG"
  if ! confirm "Proceed to clean package manager caches and attempt to remove orphaned packages where supported?"; then
    echo "Skipping package cache cleaning."
    return 0
  fi

  case "$PKG" in
    apt)
      log "Cleaning apt cache (apt-get clean) and running autoremove (confirm required)."
      apt-get clean
      if confirm "Run apt-get autoremove --purge to remove orphaned packages (may remove old kernels) ?"; then
        apt-get autoremove --purge -y
      else
        echo "Skipping apt autoremove."
      fi
      ;;
    dnf)
      dnf clean all -y
      if confirm "Run dnf autoremove to remove unused packages?"; then
        dnf autoremove -y
      fi
      ;;
    yum)
      yum clean all -y
      if confirm "Run package-cleanup --leaves to list orphaned packages? (requires yum-utils)"; then
        if ! command -v package-cleanup >/dev/null 2>&1; then
          pkg_install yum-utils
        fi
        package-cleanup --leaves
        echo "Review output and remove manually if desired."
      fi
      ;;
    pacman)
      pacman -Scc --noconfirm || true
      if confirm "Remove orphaned packages (pacman -Qtdq) ?"; then
        orphans="$(pacman -Qtdq 2>/dev/null || true)"
        if [ -n "$orphans" ]; then
          echo "$orphans"
          if confirm "Proceed to remove the above orphaned packages?"; then
            pacman -Rns --noconfirm $orphans || true
          else
            echo "Skipped removing orphans."
          fi
        else
          echo "No orphaned packages found."
        fi
      fi
      ;;
    zypper)
      zypper clean -a
      ;;
    *)
      echo "Unknown package manager: please clean caches manually."
      ;;
  esac

  # Old kernel handling (dangerous): show old kernels and ask confirmation for removal
  if [ "$PKG" = "apt" ]; then
    # Debian/Ubuntu: list linux-image-* not the running one
    current_k="$(uname -r)"
    old_kernels="$(dpkg --list 'linux-image-*' 2>/dev/null | awk '/^ii/{print $2}' | grep -v "$current_k" || true)"
    if [ -n "$old_kernels" ]; then
      echo "Old kernels detected:"
      echo "$old_kernels"
      if confirm "Purge old kernels listed above? THIS IS RISKY. Confirm to proceed."; then
        apt-get purge -y $old_kernels || echo "Some kernels may not have been purged automatically."
      else
        echo "Skipped kernel purge."
      fi
    fi
  fi

  echo "Package cache cleaning complete."
}

clean_user_caches() {
  # Explanation:
  # What: Remove common user caches (thumbnail caches, flatpak unused, snap, browser caches optionally).
  # Why: Frees disk space and reduces I/O pressure from background cache writes.
  # Risk: Removing browser caches will make browsers re-download assets; Flatpak/Snap runtime removals may
  #       break apps if you remove needed runtimes. We ask confirmation before each destructive action.
  # Revert: Caches will be rebuilt by applications; Flatpak/Snap can be reinstalled.
  log "=== clean_user_caches ==="

  if confirm "Clean common user caches (thumbnail caches, flatpak unused, snap cache)?"; then
    # Thumbnail caches (all users)
    echo "Cleaning thumbnail caches (~/.cache/thumbnails) for users..."
    for uhome in /home/*; do
      if [ -d "$uhome/.cache/thumbnails" ]; then
        rm -rf "$uhome/.cache/thumbnails" && echo "Cleaned $uhome/.cache/thumbnails"
      fi
    done
    # root
    [ -d /root/.cache/thumbnails ] && rm -rf /root/.cache/thumbnails && echo "Cleaned /root/.cache/thumbnails"

    # Flatpak unused
    if command -v flatpak >/dev/null 2>&1; then
      if confirm "Run flatpak uninstall --unused to remove unused runtimes?"; then
        flatpak uninstall --unused -y || true
      fi
    fi

    # Snap cleanup (if snapd present)
    if command -v snap >/dev/null 2>&1; then
      if confirm "Remove old snap revisions (snap set system refresh.retain=2 recommended) ?"; then
        # Show snap list with revisions
        snap list --all 2>/dev/null | awk '/disabled/{print $1, $2, $3}'
        echo "You will be prompted to remove disabled revisions."
        for snapname in $(snap list --all 2>/dev/null | awk '/disabled/{print $1}'); do
          printf "Removing disabled revisions for %s\n" "$snapname"
          snap remove "$snapname" || true
        done
      fi
    fi

    # Browser caches — too risky to auto-clean for all users; offer per-user option
    if confirm "Would you like to attempt to clear browser caches for common browsers for each user? (This will force re-download of web assets)"; then
      for uhome in /home/*; do
        [ -d "$uhome" ] || continue
        # Chrome/Chromium
        if [ -d "$uhome/.cache/google-chrome" ]; then
          rm -rf "$uhome/.cache/google-chrome" && echo "Cleaned chrome cache for $uhome"
        fi
        if [ -d "$uhome/.cache/chromium" ]; then
          rm -rf "$uhome/.cache/chromium" && echo "Cleaned chromium cache for $uhome"
        fi
        # Firefox
        if [ -d "$uhome/.cache/mozilla" ]; then
          rm -rf "$uhome/.cache/mozilla" && echo "Cleaned firefox cache for $uhome"
        fi
      done
    fi
  else
    echo "Skipping user cache cleaning."
  fi
}

clean_logs() {
  # Explanation:
  # What: Use journalctl --vacuum-size to limit journal logs and optionally rotate/remove old files in /var/log.
  # Why: Prevent disk filling up by logs and reduce I/O from excessive logging.
  # Risk: Removing old logs may remove forensic information. Journal vacuum is irreversible.
  # Revert: Cannot restore logs once removed unless backup exists.
  log "=== clean_logs ==="
  if confirm "Run 'journalctl --vacuum-size=250M' to limit journal logs to 250M? (Irreversible)"; then
    journalctl --vacuum-size=250M || true
    echo "Journal vacuumed to 250M."
  else
    echo "Skipped journal vacuum."
  fi

  if confirm "Optionally delete archived or very old logs under /var/log (careful)?"; then
    # show large files first
    echo "Largest files in /var/log:"
    find /var/log -type f -printf '%s\t%p\n' 2>/dev/null | sort -n -r | head -n 20 | awk '{printf("%.2fMB\t%s\n",$1/1024/1024,$2)}'
    if confirm "Proceed to delete log files older than 180 days in /var/log?"; then
      find /var/log -type f -mtime +180 -exec rm -f {} \; || true
      echo "Deleted logs older than 180 days in /var/log"
    else
      echo "Skipped deleting old log files."
    fi
  else
    echo "Skipped optional /var/log cleanup."
  fi
}

io_scheduler_tuning() {
  # Explanation:
  # What: Detect if primary disk is SSD or HDD and configure scheduler accordingly (transient).
  # Why: SSDs benefit from noop/mq-deadline and trimming; HDDs often perform better with bfq or mq-deadline.
  # Risk: Some tunings may not be supported by all kernels/drivers. We do NOT auto-edit fstab; only suggest changes.
  # Revert: Scheduler changes are transient; will revert on reboot unless persisted.
  log "=== io_scheduler_tuning ==="

  if [ -z "$PRIMARY_BLOCK" ]; then
    echo "Primary block device unknown; skipping scheduler tuning."
    return 0
  fi

  rotational_file="/sys/block/$PRIMARY_BLOCK/queue/rotational"
  if [ -r "$rotational_file" ]; then
    is_rotational="$(cat "$rotational_file")"
  else
    is_rotational="1"
  fi

  if [ "$is_rotational" = "0" ]; then
    echo "Primary disk ($PRIMARY_BLOCK) detected as SSD (rotational=0)."
    echo "Enabling fstrim.timer (recommended) and suggesting noatime in fstab (not auto-applied)."
    if systemctl list-unit-files | grep -q '^fstrim.timer'; then
      if confirm "Enable and start fstrim.timer to schedule periodic TRIMs?"; then
        systemctl enable --now fstrim.timer || echo "Failed to enable fstrim.timer"
      fi
    else
      echo "fstrim.timer not present on this system (older/system without systemd fstrim)."
    fi

    # Suggest adding noatime to fstab: create suggestion file
    SUGGEST_FILE="/etc/ultimate-tuner/fstab-suggestions-$TIMESTAMP"
    mkdir -p /etc/ultimate-tuner
    cat > "$SUGGEST_FILE" <<'EOF'
# Suggested fstab options for SSDs:
# For each SSD mount in /etc/fstab, consider adding 'noatime,discard' (discard only if supported)
# Example:
# UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX / ext4 defaults,noatime,discard 0 1
#
# Note: 'discard' enables continuous TRIM and may have performance implications on some SSDs.
#       Alternatively, keep discard off and rely on fstrim.timer (recommended).
EOF
    echo "Created suggestion file: $SUGGEST_FILE (contains commented fstab examples)."
  else
    echo "Primary disk ($PRIMARY_BLOCK) appears to be rotational (HDD)."
    # Try to set scheduler to bfq or mq-deadline
    available_sched_file="/sys/block/$PRIMARY_BLOCK/queue/scheduler"
    if [ -r "$available_sched_file" ]; then
      echo "Available schedulers: $(cat $available_sched_file)"
      preferred="mq-deadline"
      if grep -q "bfq" "$available_sched_file"; then
        preferred="bfq"
      fi
      echo "Attempting to set I/O scheduler to $preferred for /sys/block/$PRIMARY_BLOCK..."
      if confirm "Set I/O scheduler to $preferred (transient until next reboot)?"; then
        echo "$preferred" > "$available_sched_file" || echo "Failed to write scheduler (permission or unsupported)."
        echo "Set scheduler for $PRIMARY_BLOCK to $preferred"
      else
        echo "Skipped changing I/O scheduler."
      fi
    else
      echo "Scheduler file not present; cannot change scheduler."
    fi
  fi

  # File indexing services
  echo "Indexing services (baloo/tracker) can cause high I/O. We can stop & mask them."
  if confirm "Stop & mask common desktop indexing services (baloo, tracker)?"; then
    # baloo
    if systemctl list-units --all | grep -q baloo; then
      systemctl --now mask --no-block baloo.service baloo_file_reindex.service || true
      echo "Attempted to mask baloo services."
    fi
    # tracker
    if systemctl --type=service | grep -q tracker; then
      systemctl --now mask --no-block tracker* || true
      echo "Attempted to mask tracker services."
    fi
    echo "Indexing services stopped/masked where available."
  fi
}

clean_disk_io() {
  echo "==== Disk cleaning & I/O optimization ===="
  clean_package_caches
  clean_user_caches
  clean_logs
  io_scheduler_tuning
  echo "Disk cleaning & I/O tuning complete."
}

# ---------------------------
# 2) Advanced Memory & Swap Optimization
# ---------------------------

# Explanation:
# What: optimize_memory writes a sysctl conf with memory related tunables (swappiness, vfs_cache_pressure),
#       configures zram for systems with limited RAM, optionally drops caches, and installs earlyoom/systemd-oomd.
# Why: Reduce swapping, keep useful caches, avoid OOM storms by killing the heaviest process gracefully.
# Risk: Dropping caches hurts performance temporarily. ZRAM creates compressed swap in RAM; misconfiguration can
#       lead to lost RAM for applications if set too large. earlyoom may kill processes that users consider important.
# Revert: Remove created sysctl file and reload sysctl. Remove zram systemd unit and swap devices to revert.

generate_sysctl_mem_conf() {
  # Create /etc/sysctl.d/99-ultimate-tuner.conf with memory and network tweaks (we'll append network later)
  SYSCTL_FILE="/etc/sysctl.d/99-ultimate-tuner.conf"
  backup_file "$SYSCTL_FILE"

  cat > "$SYSCTL_FILE" <<EOF
# 99-ultimate-tuner.conf
# Generated: $TIMESTAMP
# Memory tuning
vm.swappiness=10
vm.vfs_cache_pressure=50
# Networking/perf (some network tunables; may be adjusted by optimize_network)
net.core.rmem_max=16777216
net.core.wmem_max=16777216
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 16384 16777216
# TCP modern cong alg (bbr) will be enabled separately if available
EOF

  sysctl --system || true
  echo "Wrote sysctl config $SYSCTL_FILE and reloaded sysctl."
}

drop_caches_option() {
  echo "WARNING: Dropping caches frees pagecache/dentries/inodes immediately but is NOT a long-term fix."
  echo "This may hurt performance until caches warm again. Use only if you need immediate memory."
  if confirm "Run 'sync; echo 3 > /proc/sys/vm/drop_caches' now?"; then
    sync
    # using tee to avoid shell redirection privilege issues
    echo 3 > /proc/sys/vm/drop_caches
    echo "Drop caches executed."
  else
    echo "Skipped drop caches."
  fi
}

install_oom_protector() {
  # earlyoom preferred on many distros; systemd-oomd may be available
  echo "Checking for earlyoom or systemd-oomd..."
  if command -v earlyoom >/dev/null 2>&1; then
    echo "earlyoom already installed."
    if systemctl is-enabled earlyoom >/dev/null 2>&1; then
      echo "earlyoom enabled."
    else
      if confirm "Enable and start earlyoom service?"; then
        systemctl enable --now earlyoom || true
      fi
    fi
    return 0
  fi

  if [ -f /lib/systemd/system/systemd-oomd.service ] || [ -f /usr/lib/systemd/system/systemd-oomd.service ]; then
    echo "systemd-oomd present."
    if confirm "Enable & start systemd-oomd?"; then
      systemctl enable --now systemd-oomd || true
    fi
    return 0
  fi

  # Install earlyoom as fallback
  if confirm "Install earlyoom (recommended) via package manager?"; then
    case "$PKG" in
      apt|dnf|yum|pacman|zypper)
        pkg_install earlyoom || echo "Failed to install earlyoom via package manager. Install manually."
        if command -v systemctl >/dev/null 2>&1; then
          systemctl enable --now earlyoom || true
        fi
        ;;
      *)
        echo "Unknown package manager. Please install earlyoom or enable systemd-oomd manually."
        ;;
    esac
  fi
}

setup_zram_if_needed() {
  # Create a systemd unit that sets up zram swap on boot if RAM < 16GB
  TOTAL_MEM_KB=$(awk '/MemTotal/ {print $2}' /proc/meminfo || echo 0)
  TOTAL_MEM_MB=$((TOTAL_MEM_KB/1024))
  if [ "$TOTAL_MEM_MB" -ge 16384 ]; then
    echo "System has $TOTAL_MEM_MB MB RAM (>=16GB). Skipping automatic ZRAM setup recommendation."
    return 0
  fi

  echo "System RAM is ${TOTAL_MEM_MB}MB (<16GB). Configuring a zram swap device may improve responsiveness."
  if ! confirm "Create and enable a zram swap device with systemd unit? (Uses zstd compression if available)"; then
    echo "Skipped zram setup."
    return 0
  fi

  # Create systemd unit and script
  ZRAM_SERVICE="/etc/systemd/system/zram-ultimate-tuner.service"
  backup_file "$ZRAM_SERVICE"
  # Calculate zram size: use 50% of RAM as compressed swap target (adjustable)
  zram_size_mb=$((TOTAL_MEM_MB / 2))
  if [ "$zram_size_mb" -lt 256 ]; then zram_size_mb=256; fi

  cat > "$ZRAM_SERVICE" <<EOF
[Unit]
Description=Create zram swap for Ultimate Tuner
After=default.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/sbin/ultimate-tuner-zram-setup.sh start
ExecStop=/usr/local/sbin/ultimate-tuner-zram-setup.sh stop
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

  ZRAM_SCRIPT="/usr/local/sbin/ultimate-tuner-zram-setup.sh"
  backup_file "$ZRAM_SCRIPT"
  cat > "$ZRAM_SCRIPT" <<EOF
#!/usr/bin/env bash
# Simple zram setup script created by linux_ultimate_tuner
ACTION="\${1:-start}"
ZRAM_DEVICE="/dev/zram0"
ZRAM_SIZE_MB="${zram_size_mb}"

modprobe zram
if [ "\$ACTION" = "start" ]; then
  echo "\$ZRAM_SIZE_MB"M > /sys/block/zram0/disksize 2>/dev/null || true
  # prefer zstd if available
  if command -v zstd >/dev/null 2>&1; then
    echo zstd > /sys/block/zram0/comp_algorithm 2>/dev/null || true
  fi
  mkswap \$ZRAM_DEVICE 2>/dev/null || true
  swapon -p 5 \$ZRAM_DEVICE || true
  exit 0
else
  swapoff \$ZRAM_DEVICE || true
  echo 1 > /sys/block/zram0/reset 2>/dev/null || true
  exit 0
fi
EOF
  chmod +x "$ZRAM_SCRIPT"
  systemctl daemon-reload
  systemctl enable --now zram-ultimate-tuner.service || echo "Failed to enable zram service; run the script manually /usr/local/sbin/ultimate-tuner-zram-setup.sh start"

  echo "ZRAM service created: $ZRAM_SERVICE"
  echo "To remove: systemctl disable --now zram-ultimate-tuner.service; run $ZRAM_SCRIPT stop; rm $ZRAM_SERVICE $ZRAM_SCRIPT"
}

optimize_memory() {
  echo "=== Memory & swap optimization ==="
  generate_sysctl_mem_conf
  if confirm "Would you like to drop caches now (transient)?"; then
    drop_caches_option
  fi
  install_oom_protector
  setup_zram_if_needed
  echo "Memory optimization complete."
}

# ---------------------------
# 3) CPU & Process Scheduling Tuning
# ---------------------------

# Explanation:
# What: configure CPU governor, enable irqbalance, provide interactive renice and taskset functionality.
# Why: Ensure consistent CPU performance and proper distribution of IRQs; allow pinning/priority for critical tasks.
# Risk: Setting performance governor on laptops increases power consumption. Renicing can starve other processes
#       if incorrect priority is set. Pinning processes may reduce responsiveness for others.
# Revert: Governor settings revert on reboot unless persisted; reniced processes can be reniced back to default; taskset changes persist only for running processes.

set_cpu_governor() {
  echo "=== set_cpu_governor ==="
  if [ "$IS_LAPTOP" -eq 1 ]; then
    echo "Laptop detected: default behavior is to NOT force performance governor."
    if confirm "Force performance governor on laptop (not recommended)?"; then
      FORCE=1
    else
      FORCE=0
    fi
  else
    FORCE=1
  fi

  if [ "$FORCE" -eq 1 ]; then
    # Attempt to set scaling governor for each cpu
    for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
      govfile="$cpu/cpufreq/scaling_governor"
      if [ -w "$govfile" ]; then
        echo "performance" > "$govfile" || true
      fi
    done
    echo "Requested performance governor (transient). To persist across boots, use distro-specific tools (cpupower, tuned, or governor config)."
  else
    echo "Skipped forcing performance governor."
  fi
}

enable_irqbalance() {
  echo "=== enable_irqbalance ==="
  if command -v irqbalance >/dev/null 2>&1; then
    systemctl enable --now irqbalance || echo "Failed to enable irqbalance"
    echo "irqbalance enabled."
  else
    if confirm "Install irqbalance via package manager?"; then
      pkg_install irqbalance || echo "Failed to install irqbalance"
      systemctl enable --now irqbalance || true
    else
      echo "Skipped irqbalance installation."
    fi
  fi
}

process_niceness_and_pinning() {
  echo "=== Process niceness & pinning ==="
  ps -eo pid,ni,cmd --sort=-%cpu | head -n 20
  echo "You can renice a PID or pin it to CPUs."
  if confirm "Renice a process?"; then
    read -rp "Enter PID to renice: " pid
    read -rp "Enter niceness (-20..19, lower is higher priority, recommended -10 for boosted): " niceval
    if [ -n "$pid" ] && [ -n "$niceval" ]; then
      renice -n "$niceval" -p "$pid" && echo "Reniced PID $pid to $niceval"
    fi
  fi

  if confirm "Pin a process to specific CPU cores using taskset?"; then
    read -rp "Enter PID to pin: " pid
    read -rp "Enter CPU list (e.g., 0 or 0,2 or 1-3): " cpulist
    if [ -n "$pid" ] && [ -n "$cpulist" ]; then
      # convert cpulist to mask using python if available, else attempt naive
      if command -v taskset >/dev/null 2>&1; then
        taskset -cp "$cpulist" "$pid" && echo "Pinned PID $pid to CPUs $cpulist"
      else
        echo "taskset not available on this system. Install util-linux or equivalent."
      fi
    fi
  fi
}

optimize_cpu() {
  echo "=== CPU & scheduling tuning ==="
  set_cpu_governor
  enable_irqbalance
  process_niceness_and_pinning
  echo "CPU tuning complete."
}

# ---------------------------
# 4) Advanced Network Tuning
# ---------------------------

# Explanation:
# What: configure systemd-resolved as local caching DNS if desired, tune TCP/IP sysctls (bbr), and disable NIC features like EEE via ethtool.
# Why: Reduce DNS latency, enable modern congestion control and increase network throughput.
# Risk: Changing network parameters may affect connectivity if misapplied; disabling NIC features may be unsupported on some hardware.
# Revert: Remove or restore sysctl file and reload sysctl; re-enable NIC features via ethtool.

enable_systemd_resolved() {
  echo "=== Configuring systemd-resolved as local caching DNS stub resolver ==="
  if ! command -v systemd-resolve >/dev/null 2>&1 && ! command -v resolvectl >/dev/null 2>&1; then
    echo "systemd-resolved/resolvectl not found. Skipping."
    return 0
  fi

  if systemctl is-enabled --quiet systemd-resolved; then
    echo "systemd-resolved already enabled."
    return 0
  fi

  if confirm "Enable and start systemd-resolved (will manage /etc/resolv.conf)?"; then
    systemctl enable --now systemd-resolved || echo "Failed to enable systemd-resolved."
    # Ensure /etc/resolv.conf is a symlink to /run/systemd/resolve/stub-resolv.conf or compatible
    if [ -f /run/systemd/resolve/stub-resolv.conf ]; then
      backup_file /etc/resolv.conf
      ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf
      echo "/etc/resolv.conf symlinked to /run/systemd/resolve/stub-resolv.conf"
    fi
  else
    echo "Skipped enabling systemd-resolved."
  fi
}

enable_bbr_and_network_sysctls() {
  echo "=== Enabling BBR and network sysctls in /etc/sysctl.d/99-ultimate-tuner.conf ==="
  SYSCTL_FILE="/etc/sysctl.d/99-ultimate-tuner.conf"
  if [ -f "$SYSCTL_FILE" ]; then
    backup_file "$SYSCTL_FILE"
  fi
  # Append or create
  cat >> "$SYSCTL_FILE" <<EOF

# Network tuning (added by linux_ultimate_tuner on $TIMESTAMP)
net.core.rmem_max=16777216
net.core.wmem_max=16777216
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 16384 16777216
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr
EOF
  # Try to load bbr
  if modprobe tcp_bbr 2>/dev/null; then
    echo "Loaded tcp_bbr module."
  else
    echo "tcp_bbr module not loadable or not present. Kernel may lack BBR support."
  fi
  sysctl --system || true
  echo "Network sysctls applied (may require reboot to fully enable BBR)."
}

nic_tuning_ethtool() {
  # Identify primary NIC (the one with default route)
  echo "=== NIC tuning (ethtool) ==="
  PRIMARY_IF=""
  PRIMARY_IF="$(ip route get 8.8.8.8 2>/dev/null | awk '/dev/ {for(i=1;i<=NF;i++) if($i=="dev") print $(i+1)}' | head -n1 || true)"
  [ -z "$PRIMARY_IF" ] && PRIMARY_IF="$(ip route | awk '/default/ {print $5; exit}')"
  if [ -z "$PRIMARY_IF" ]; then
    echo "Could not determine primary network interface. Skipping ethtool tweaks."
    return 0
  fi
  echo "Primary interface detected: $PRIMARY_IF"
  if ! command -v ethtool >/dev/null 2>&1; then
    if confirm "ethtool not found. Install ethtool via package manager?"; then
      pkg_install ethtool || echo "Failed to install ethtool"
    else
      return 0
    fi
  fi

  # Show current features
  ethtool --show-features "$PRIMARY_IF" 2>/dev/null || true
  if confirm "Disable Energy-Efficient Ethernet (EEE) on $PRIMARY_IF? (May reduce latency spikes)"; then
    ethtool --set-eee "$PRIMARY_IF" eee off 2>/dev/null || echo "Failed to disable EEE or not supported."
  fi
  echo "You may also consider tuning ring buffers and interrupt coalescing via ethtool -G/-C."
}

optimize_network() {
  echo "=== Network tuning ==="
  enable_systemd_resolved
  enable_bbr_and_network_sysctls
  nic_tuning_ethtool
  echo "Network optimization complete."
}

# ---------------------------
# 5) Automated Backup & System Snapshots (Timeshift)
# ---------------------------

# Explanation:
# What: Detect timeshift and offer to install, configure for BTRFS or rsync mode, and create a pre-optimization snapshot.
# Why: Snapshots provide a safety net before applying system-wide tweaks.
# Risk: Timeshift installations may vary by distro; BTRFS snapshots require BTRFS filesystem.
# Revert: Snapshots may be restored via Timeshift UI or CLI.

setup_backups() {
  echo "=== Automated backups & Timeshift integration ==="
  if ! command -v timeshift >/dev/null 2>&1; then
    if confirm "Timeshift not installed. Install Timeshift (recommended)?"; then
      case "$PKG" in
        apt)
          add-apt-repository -y ppa:teejee2008/ppa || true
          apt update -y || true
          apt install -y timeshift || echo "Install timeshift manually if not available."
          ;;
        dnf|yum|pacman|zypper)
          pkg_install timeshift || echo "Install timeshift manually."
          ;;
        *)
          echo "Unknown package manager; install timeshift manually if desired."
          ;;
      esac
    fi
  fi

  if command -v timeshift >/dev/null 2>&1; then
    # Determine mode
    if [ "$ROOT_FS" = "btrfs" ]; then
      TS_MODE="btrfs"
    else
      TS_MODE="rsync"
    fi
    echo "Timeshift available. Suggested mode: $TS_MODE"

    if confirm "Configure Timeshift with mode $TS_MODE now?"; then
      # Create basic timeshift config (non-invasive)
      TIMESHIFT_CONF="/etc/timeshift.json"
      backup_file "$TIMESHIFT_CONF"
      cat > "$TIMESHIFT_CONF" <<EOF
{
  "backup_device_uuid": "",
  "snapshot_device": "",
  "do_first_run": "false",
  "btrfs_mode": $( [ "$TS_MODE" = "btrfs" ] && echo "true" || echo "false" ),
  "rsync_mode": $( [ "$TS_MODE" = "rsync" ] && echo "true" || echo "false" )
}
EOF
      echo "Timeshift config written to $TIMESHIFT_CONF (basic). You may customize via timeshift-gtk or timeshift --restore."
    fi

    if confirm "Create a pre-optimization Timeshift snapshot now (name: Pre-Ultimate-Tuner-$TIMESTAMP)?"; then
      # Using timeshift --create
      timeshift --create --comments "Pre-Ultimate-Tuner-$TIMESTAMP" --tags D || echo "Timeshift snapshot creation failed or requires GUI/manual steps."
    fi
  else
    echo "Timeshift not installed or unavailable. Consider installing for snapshots."
  fi
}

# ---------------------------
# 6) Container & Runtime Cleanup
# ---------------------------

# Explanation:
# What: Detect Docker/Podman and offer aggressive prune of unused containers/images/volumes.
# Why: Containers and images can consume large disk space; pruning reclaims space.
# Risk: Pruning removes unused images/volumes and may delete data you intended to keep.
# Revert: Pruned items cannot be restored unless you have backups or re-pull images.

clean_containers() {
  echo "=== Container & runtime cleanup ==="
  if command -v docker >/dev/null 2>&1; then
    echo "Docker detected."
    if confirm "Run 'docker system prune -af --volumes' to aggressively remove unused Docker objects?"; then
      docker system prune -af --volumes || echo "docker prune failed"
    else
      echo "Skipped docker prune."
      if confirm "List dangling images and volumes?"; then
        docker images -f dangling=true
        docker volume ls -f dangling=true
        if confirm "Remove dangling volumes?"; then
          docker volume prune -f || true
        fi
      fi
    fi
  fi

  if command -v podman >/dev/null 2>&1; then
    echo "Podman detected."
    if confirm "Run 'podman system prune -a --volumes -f' to aggressively remove unused Podman objects?"; then
      podman system prune -a --volumes -f || echo "podman prune failed"
    fi
  fi

  if ! command -v docker >/dev/null 2>&1 && ! command -v podman >/dev/null 2>&1; then
    echo "No Docker or Podman detected."
  fi
}

# ---------------------------
# 7) Intelligent Power Management (Laptop-only)
# ---------------------------

# Explanation:
# What: For laptops only: install & configure power management tools like tlp or auto-cpufreq. Set sane defaults for AC vs battery.
# Why: These tools intelligently manage power profiles and can extend battery life without manual governor toggles.
# Risk: May change behavior of devices (e.g., Bluetooth, wifi power saving). Defaults chosen to be conservative.
# Revert: Uninstall or disable tlp/auto-cpufreq; restore configs from backups.

optimize_power() {
  if [ "$IS_LAPTOP" -ne 1 ]; then
    echo "Skipping power management: no battery detected (desktop/bare-metal)."
    return 0
  fi

  echo "=== Laptop power management ==="
  if confirm "Install and configure TLP (recommended) for intelligent power management?"; then
    pkg_install tlp || echo "Failed to install TLP. Consider installing auto-cpufreq as alternative."
    if command -v tlp >/dev/null 2>&1; then
      systemctl enable --now tlp || true
      echo "TLP enabled. Default settings prefer battery savings; modify /etc/tlp.conf to tune."
    fi
  else
    echo "Skipping TLP installation."
  fi

  if confirm "Optionally install auto-cpufreq (automatic CPU frequency scaling based on usage) instead of/in addition to TLP?"; then
    # auto-cpufreq packaging varies by distro; attempt installation via pip or package manager
    if [ "$PKG" = "apt" ]; then
      apt install -y python3-pip || true
      pip3 install --upgrade auto-cpufreq || true
    else
      pip3 install --upgrade auto-cpufreq || true
    fi
    if command -v auto-cpufreq >/dev/null 2>&1; then
      auto-cpufreq --install || true
      echo "auto-cpufreq installed."
    else
      echo "auto-cpufreq not installed automatically; please install manually if desired."
    fi
  fi

  echo "Power management setup complete. Check TLP settings in /etc/tlp.conf and auto-cpufreq docs."
}

# ---------------------------
# 8) System Monitoring & Health Checks
# ---------------------------

# Explanation:
# What: Offer to install monitoring tools (htop, btop, ncdu, smartmontools), then generate a health report including system metrics and SMART status.
# Why: Provide an overview of system health and quick diagnostics for performance regressions.
# Risk: None significant. smartctl may require root (we run as root).
# Revert: Not applicable; installation can be removed by package manager.

install_monitoring_tools() {
  echo "Installing recommended monitoring tools (htop, btop, ncdu, smartmontools)..."
  pkg_install htop ncdu smartmontools || true
  # btop may not be packaged on all distros; attempt to install via package manager, else skip
  case "$PKG" in
    apt) apt install -y btop || true ;;
    dnf) dnf install -y btop || true ;;
    pacman) pacman -S --noconfirm btop || true ;;
    zypper) zypper --non-interactive install btop || true ;;
    *) echo "Install btop manually if desired." ;;
  esac
}

generate_health_report() {
  echo "=== System Health Report ==="
  echo "Generated: $(date)"
  echo ""
  echo "Uptime & load:"
  uptime
  echo ""
  echo "Memory & swap (MB):"
  free -m
  echo ""
  echo "Top memory consumers:"
  ps aux --sort=-%mem | awk 'NR<=10{printf "%-8s %-6s %-6s %s\n",$2,$3,$4,$11}'
  echo ""
  echo "Disk usage (primary partitions):"
  df -hT | awk 'NR==1 || /^\/dev\// {print}'
  echo ""
  echo "Critical services status (systemd-resolved, tlp, earlyoom, irqbalance):"
  for svc in systemd-resolved tlp earlyoom irqbalance; do
    if systemctl list-units --all --type=service | grep -q "$svc"; then
      systemctl status "$svc" --no-pager --lines=0 || true
    else
      echo "$svc: not present"
    fi
  done
  echo ""
  echo "Failed systemd units:"
  systemctl --state=failed --no-legend || echo "None"
  echo ""
  # SMART check on primary drives
  if command -v smartctl >/dev/null 2>&1; then
    echo "SMART check for primary block device(s):"
    for dev in /dev/"$PRIMARY_BLOCK"; do
      if [ -b "$dev" ]; then
        echo "smartctl -H $dev:"
        smartctl -H "$dev" || true
      fi
    done
  else
    echo "smartctl not installed. Install smartmontools to enable drive health checks."
  fi
  echo ""
  echo "Health report complete."
}

system_health() {
  echo "=== System monitoring & health checks ==="
  if confirm "Install monitoring tools (htop, btop, ncdu, smartmontools)?"; then
    install_monitoring_tools
  fi
  generate_health_report | tee "/var/log/ultimate-tuner-healthreport-$TIMESTAMP.txt"
  echo "Health report saved to /var/log/ultimate-tuner-healthreport-$TIMESTAMP.txt"
}

# ---------------------------
# Utility: Run All (with snapshots & confirmation)
# ---------------------------

run_full_suite() {
  echo "=== Running full Ultimate Tuner suite ==="
  echo "This will make multiple system changes (sysctl, services, package removals, zram, etc.)."
  if ! confirm "Proceed to run the entire suite? It's strongly recommended to create a snapshot (Timeshift) before continuing."; then
    echo "Aborted running full suite."
    return 1
  fi

  # Offer timeshift snapshot
  if command -v timeshift >/dev/null 2>&1; then
    if confirm "Create a Pre-Ultimate-Tuner timeshift snapshot now?"; then
      timeshift --create --comments "Pre-Ultimate-Tuner-$TIMESTAMP" --tags D || echo "Timeshift snapshot creation failed or not configured."
    fi
  fi

  # Execute sections
  clean_disk_io
  optimize_memory
  optimize_cpu
  optimize_network
  setup_backups
  clean_containers
  optimize_power
  system_health

  echo "Full suite executed. Review changes and reboots may be required for some effects (e.g., BBR activation)."
}

# ---------------------------
# Interactive Menu
# ---------------------------

show_menu() {
  cat <<'EOF'

===== Linux Ultimate Tuner - Interactive Menu =====
Choose an action by number (type the number and press Enter):

  1) Detect environment (distro, virtualization, laptop, CPU, filesystem)
  2) Disk cleaning & I/O optimization
     - package cache cleanup
     - user cache cleanup
     - journal/log vacuum
     - I/O scheduler tuning & SSD suggestions
  3) Memory & swap optimization (sysctl, zram, earlyoom, drop caches)
  4) CPU & process tuning (governor, irqbalance, renice/taskset)
  5) Network optimization (systemd-resolved, BBR, NIC tweaks)
  6) Setup backups & Timeshift integration
  7) Container cleanup (Docker/Podman prune)
  8) Power management (laptop-only: TLP/auto-cpufreq)
  9) System monitoring & health checks (install tools + report)
 10) Run entire suite (recommended only after snapshot)
 11) Generate health report only
 12) Exit
===================================================

EOF
}

main_loop() {
  detect_all
  while true; do
    show_menu
    read -rp "Select option: " opt
    case "$opt" in
      1) detect_all ;;
      2) clean_disk_io ;;
      3) optimize_memory ;;
      4) optimize_cpu ;;
      5) optimize_network ;;
      6) setup_backups ;;
      7) clean_containers ;;
      8) optimize_power ;;
      9) system_health ;;
      10) run_full_suite ;;
      11) generate_health_report ;;
      12) echo "Exiting. Remember to review backups in $BACKUP_DIR"; exit 0 ;;
      *) echo "Invalid option. Try again." ;;
    esac
    echo "Operation complete. Returning to menu..."
  done
}

# ---------------------------
# Script entrypoint
# ---------------------------

main() {
  echo "linux_ultimate_tuner.sh - Ultimate system tuning and safety toolkit"
  echo "All changes will create backups in: $BACKUP_DIR"
  if ! confirm "Continue and open the interactive menu?"; then
    echo "Exiting per user request."
    exit 0
  fi
  main_loop
}

main "$@"
