#!/bin/bash

# =====================================================================
# Linux Ultimate Tuner - Advanced System Optimization Script
# =====================================================================
# 
# Author: Advanced Linux System Administrator
# Purpose: Comprehensive system optimization for desktop Linux installations
# Target: Ubuntu, Fedora, Arch Linux and derivatives
# 
# This script aggressively optimizes Linux systems for maximum performance,
# stability, and control. It's designed for developers, gamers, and power users
# who demand the best from their hardware.
#
# SAFETY NOTICE: Always create system snapshots before running optimizations!
# =====================================================================

set -euo pipefail  # Exit on any error, undefined variable, or pipe failure

# Global configuration
readonly SCRIPT_NAME="Linux Ultimate Tuner"
readonly VERSION="2.0"
readonly BACKUP_DIR="/tmp/linux_tuner_backups_$(date +%Y%m%d_%H%M%S)"
readonly LOG_FILE="/tmp/linux_tuner_$(date +%Y%m%d_%H%M%S).log"

# Color codes for enhanced user experience
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m' # No Color

# System detection variables
DISTRO=""
PACKAGE_MANAGER=""
IS_LAPTOP=false
IS_VM=false
CPU_CORES=""
TOTAL_RAM_GB=""
HAS_SSD=false
FILESYSTEM_TYPE=""

# =====================================================================
# Utility Functions - The Foundation of Our System
# =====================================================================

log() {
    # Comprehensive logging function that writes to both console and log file
    # This helps with debugging and provides an audit trail of all operations
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case "$level" in
        "ERROR")   echo -e "${RED}[ERROR]${NC} $message" | tee -a "$LOG_FILE" ;;
        "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} $message" | tee -a "$LOG_FILE" ;;
        "WARNING") echo -e "${YELLOW}[WARNING]${NC} $message" | tee -a "$LOG_FILE" ;;
        "INFO")    echo -e "${CYAN}[INFO]${NC} $message" | tee -a "$LOG_FILE" ;;
        *)         echo -e "$message" | tee -a "$LOG_FILE" ;;
    esac
}

check_root() {
    # Root privileges are essential for system-level optimizations
    # Without them, we can't modify kernel parameters, install packages, or tune hardware
    if [[ $EUID -ne 0 ]]; then
        log "ERROR" "This script requires root privileges for system-level optimizations."
        log "INFO" "Please run with: sudo $0"
        exit 1
    fi
    log "SUCCESS" "Root privileges confirmed."
}

create_backup_directory() {
    # Creating timestamped backups ensures we can always revert changes
    # This is crucial for production systems where stability is paramount
    mkdir -p "$BACKUP_DIR"
    log "INFO" "Backup directory created at: $BACKUP_DIR"
    
    # Create a restoration script for easy rollback
    cat > "$BACKUP_DIR/restore.sh" << 'EOF'
#!/bin/bash
# Automatic restoration script generated by Linux Ultimate Tuner
echo "Restoring system configuration from backup..."
# Individual restore commands will be added here by backup functions
EOF
    chmod +x "$BACKUP_DIR/restore.sh"
}

backup_file() {
    # Individual file backup function with restoration command generation
    local file="$1"
    if [[ -f "$file" ]]; then
        cp "$file" "$BACKUP_DIR/$(basename "$file").backup"
        echo "cp \"$BACKUP_DIR/$(basename "$file").backup\" \"$file\"" >> "$BACKUP_DIR/restore.sh"
        log "INFO" "Backed up: $file"
    fi
}

# =====================================================================
# System Detection - Understanding Our Hardware Environment
# =====================================================================

detect_system_type() {
    # Virtual machine detection is crucial because VMs have different optimization needs
    # For example, some power management features are irrelevant in VMs
    log "INFO" "Detecting system environment..."
    
    # Check for virtualization using multiple methods for reliability
    if [[ -f /proc/cpuinfo ]] && grep -q "hypervisor" /proc/cpuinfo; then
        IS_VM=true
    elif [[ -d /proc/vz ]]; then
        IS_VM=true  # OpenVZ container
    elif [[ -f /proc/xen ]]; then
        IS_VM=true  # Xen hypervisor
    elif systemd-detect-virt &>/dev/null; then
        if [[ "$(systemd-detect-virt)" != "none" ]]; then
            IS_VM=true
        fi
    fi
    
    if [[ "$IS_VM" == true ]]; then
        log "WARNING" "Virtual machine detected - some optimizations will be skipped."
    else
        log "SUCCESS" "Bare metal system detected - full optimization available."
    fi
}

detect_laptop() {
    # Laptop detection determines if we need battery-aware optimizations
    # Different power management strategies apply to laptops vs desktops
    log "INFO" "Checking for laptop hardware..."
    
    if [[ -d /sys/class/power_supply ]]; then
        # Look for battery presence in multiple locations
        if find /sys/class/power_supply -name "BAT*" -type d | grep -q .; then
            IS_LAPTOP=true
        elif [[ -f /proc/acpi/battery/BAT0/info ]] || [[ -f /proc/acpi/battery/BAT1/info ]]; then
            IS_LAPTOP=true
        fi
    fi
    
    if [[ "$IS_LAPTOP" == true ]]; then
        log "INFO" "Laptop detected - enabling battery-aware optimizations."
    else
        log "INFO" "Desktop system detected - using performance-focused settings."
    fi
}

detect_distribution() {
    # Distribution detection ensures we use the correct package manager and paths
    # Different distros have different conventions and available packages
    log "INFO" "Detecting Linux distribution..."
    
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        DISTRO="$ID"
        
        case "$DISTRO" in
            ubuntu|debian)
                PACKAGE_MANAGER="apt"
                ;;
            fedora|rhel|centos)
                PACKAGE_MANAGER="dnf"
                ;;
            arch|manjaro)
                PACKAGE_MANAGER="pacman"
                ;;
            opensuse*)
                PACKAGE_MANAGER="zypper"
                ;;
            *)
                log "WARNING" "Unsupported distribution: $DISTRO. Attempting generic optimizations."
                PACKAGE_MANAGER="unknown"
                ;;
        esac
        
        log "SUCCESS" "Detected: $PRETTY_NAME (Package manager: $PACKAGE_MANAGER)"
    else
        log "ERROR" "Cannot detect distribution. /etc/os-release not found."
        exit 1
    fi
}

detect_hardware() {
    # Hardware detection helps us make informed optimization decisions
    # CPU cores determine thread counts, RAM affects cache settings, SSD vs HDD affects I/O scheduling
    log "INFO" "Analyzing hardware configuration..."
    
    # CPU core detection
    CPU_CORES=$(nproc)
    log "INFO" "CPU cores detected: $CPU_CORES"
    
    # RAM detection (convert from KB to GB)
    local ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    TOTAL_RAM_GB=$((ram_kb / 1024 / 1024))
    log "INFO" "Total RAM detected: ${TOTAL_RAM_GB}GB"
    
    # Storage type detection - SSD vs HDD affects optimization strategies
    if lsblk -d -o NAME,ROTA | grep -q "0$"; then
        HAS_SSD=true
        log "INFO" "SSD storage detected - enabling SSD-specific optimizations."
    else
        log "INFO" "HDD storage detected - using HDD-optimized settings."
    fi
    
    # Filesystem detection for snapshot capabilities
    FILESYSTEM_TYPE=$(findmnt -n -o FSTYPE /)
    log "INFO" "Root filesystem: $FILESYSTEM_TYPE"
}

# =====================================================================
# Package Management - Foundation for System Health
# =====================================================================

update_system() {
    # System updates are the foundation of security and stability
    # Outdated packages can have security vulnerabilities and performance issues
    log "INFO" "Updating system packages..."
    
    case "$PACKAGE_MANAGER" in
        apt)
            apt update && apt upgrade -y
            apt autoremove -y
            ;;
        dnf)
            dnf update -y
            dnf autoremove -y
            ;;
        pacman)
            pacman -Syu --noconfirm
            pacman -Rns $(pacman -Qtdq) --noconfirm 2>/dev/null || true
            ;;
        zypper)
            zypper update -y
            zypper packages --unneeded | awk -F'|' 'NR==0 || NF==5 {print $3}' | xargs zypper remove -y
            ;;
    esac
    
    log "SUCCESS" "System packages updated successfully."
}

install_essential_tools() {
    # Essential tools provide better system monitoring and management capabilities
    # These tools help users understand what optimizations are doing to their system
    log "INFO" "Installing essential system monitoring and optimization tools..."
    
    local tools_apt="htop btop glances iotop nethogs ncdu tree inxi neofetch tuned irqbalance preload"
    local tools_dnf="htop btop glances iotop-c nethogs ncdu tree inxi neofetch tuned irqbalance preload"
    local tools_pacman="htop btop glances iotop nethogs ncdu tree inxi neofetch tuned irqbalance preload"
    
    case "$PACKAGE_MANAGER" in
        apt)
            apt install -y $tools_apt
            ;;
        dnf)
            dnf install -y $tools_dnf
            ;;
        pacman)
            pacman -S --noconfirm $tools_pacman
            ;;
    esac
    
    log "SUCCESS" "Essential tools installed."
}

# =====================================================================
# Aggressive Disk Cleaning & I/O Optimization
# =====================================================================

deep_system_cleanup() {
    # Deep cleanup recovers significant disk space and improves performance
    # Cached data can consume gigabytes and slow down the system over time
    log "INFO" "Performing aggressive disk cleanup..."
    
    # Package manager cache cleanup
    case "$PACKAGE_MANAGER" in
        apt)
            apt clean
            apt autoclean
            # Clean old kernel packages (keeping current + 1 previous)
            apt autoremove --purge -y
            ;;
        dnf)
            dnf clean all
            # Remove old kernels
            dnf remove $(dnf repoquery --installonly --latest-limit=-2 -q) -y 2>/dev/null || true
            ;;
        pacman)
            pacman -Scc --noconfirm
            # Clean package cache except for installed versions
            paccache -rk2 2>/dev/null || true
            ;;
    esac
    
    # Systemd journal cleanup - journals can grow very large over time
    log "INFO" "Cleaning systemd journals..."
    journalctl --vacuum-size=100M
    journalctl --vacuum-time=30d
    
    # Log file cleanup - old logs consume space and slow searches
    log "INFO" "Cleaning system logs..."
    find /var/log -name "*.log" -type f -mtime +7 -delete 2>/dev/null || true
    find /var/log -name "*.gz" -type f -delete 2>/dev/null || true
    
    # Clean user caches - thumbnails and app caches can be huge
    log "INFO" "Cleaning user caches..."
    if [[ -d /home ]]; then
        find /home -name ".cache" -type d -exec rm -rf {}/thumbnails \; 2>/dev/null || true
        find /home -name ".cache" -type d -exec find {} -name "*.tmp" -delete \; 2>/dev/null || true
    fi
    
    # Flatpak cleanup - remove unused runtimes
    if command -v flatpak &>/dev/null; then
        log "INFO" "Cleaning Flatpak unused runtimes..."
        flatpak uninstall --unused -y 2>/dev/null || true
    fi
    
    # Snap cleanup - remove old versions
    if command -v snap &>/dev/null; then
        log "INFO" "Cleaning old Snap versions..."
        snap list --all | awk '/disabled/{print $1, $3}' | while read snapname revision; do
            snap remove "$snapname" --revision="$revision" 2>/dev/null || true
        done
    fi
    
    log "SUCCESS" "Deep system cleanup completed."
}

optimize_disk_io() {
    # I/O optimization dramatically improves system responsiveness
    # Different storage types require different optimization strategies
    log "INFO" "Optimizing disk I/O performance..."
    
    backup_file "/etc/fstab"
    
    if [[ "$HAS_SSD" == true ]]; then
        log "INFO" "Applying SSD optimizations..."
        
        # Enable TRIM support for SSD longevity and performance
        systemctl enable fstrim.timer
        systemctl start fstrim.timer
        
        # Set SSD-optimized I/O scheduler
        for disk in /sys/block/sd*; do
            if [[ -f "$disk/queue/scheduler" ]]; then
                echo "mq-deadline" > "$disk/queue/scheduler" 2>/dev/null || true
            fi
        done
        
        log "SUCCESS" "SSD optimizations applied (TRIM enabled, mq-deadline scheduler)."
    else
        log "INFO" "Applying HDD optimizations..."
        
        # Set HDD-optimized I/O scheduler
        for disk in /sys/block/sd*; do
            if [[ -f "$disk/queue/scheduler" ]]; then
                echo "bfq" > "$disk/queue/scheduler" 2>/dev/null || true
            fi
        done
        
        log "SUCCESS" "HDD optimizations applied (BFQ scheduler for better interactivity)."
    fi
}

disable_file_indexing() {
    # File indexing can significantly impact system performance
    # Most power users prefer manual file management over automated indexing
    log "INFO" "Disabling file indexing services..."
    
    # Disable GNOME Tracker
    if systemctl --user is-enabled tracker-miner-fs &>/dev/null; then
        systemctl --user mask tracker-miner-fs
        systemctl --user mask tracker-extract
        systemctl --user mask tracker-store
        log "SUCCESS" "GNOME Tracker disabled."
    fi
    
    # Disable KDE Baloo
    if command -v balooctl &>/dev/null; then
        balooctl suspend
        balooctl disable
        log "SUCCESS" "KDE Baloo disabled."
    fi
    
    # Create user config to prevent re-enabling
    mkdir -p /etc/skel/.config
    cat > /etc/skel/.config/baloofilerc << EOF
[Basic Settings]
Indexing-Enabled=false
EOF
    
    log "SUCCESS" "File indexing services disabled for improved performance."
}

# =====================================================================
# Advanced Memory Optimization
# =====================================================================

optimize_memory_management() {
    # Memory optimization affects overall system responsiveness
    # These settings balance performance with system stability
    log "INFO" "Optimizing memory management..."
    
    backup_file "/etc/sysctl.conf"
    
    # Create optimized sysctl configuration
    cat >> /etc/sysctl.conf << EOF

# Linux Ultimate Tuner - Memory Optimizations
# Applied on $(date)

# Reduce swap usage - only swap when RAM is nearly full
# Lower values make the system more responsive but use more RAM
vm.swappiness=10

# Improve cache pressure management
# Lower values keep more cache in memory longer
vm.vfs_cache_pressure=50

# Optimize dirty page handling for better I/O performance
vm.dirty_ratio=15
vm.dirty_background_ratio=5

# Improve memory allocation efficiency
vm.mmap_min_addr=65536

# Enhanced network buffer management
net.core.rmem_max=16777216
net.core.wmem_max=16777216
net.ipv4.tcp_rmem=4096 16384 16777216
net.ipv4.tcp_wmem=4096 16384 16777216

# TCP optimization for modern networks
net.ipv4.tcp_congestion_control=bbr
net.core.default_qdisc=fq
EOF
    
    # Apply settings immediately
    sysctl -p
    
    log "SUCCESS" "Memory management optimized with aggressive performance settings."
}

setup_zram() {
    # ZRAM provides compressed RAM that improves performance on systems with limited memory
    # It's especially beneficial for systems with 8GB or less RAM
    if [[ "$TOTAL_RAM_GB" -le 8 ]]; then
        log "INFO" "Setting up ZRAM compression for improved memory efficiency..."
        
        case "$PACKAGE_MANAGER" in
            apt)
                apt install -y zram-config
                ;;
            dnf)
                dnf install -y zram-generator
                ;;
            pacman)
                pacman -S --noconfirm zram-generator
                ;;
        esac
        
        # Configure ZRAM with optimal settings
        mkdir -p /etc/systemd/zram-generator.conf.d
        cat > /etc/systemd/zram-generator.conf.d/zram-config.conf << EOF
[zram0]
zram-size = ram / 2
compression-algorithm = zstd
swap-priority = 100
EOF
        
        systemctl daemon-reload
        systemctl enable systemd-zram-setup@zram0.service
        
        log "SUCCESS" "ZRAM configured with ZSTD compression algorithm."
    else
        log "INFO" "Sufficient RAM detected (${TOTAL_RAM_GB}GB) - ZRAM setup skipped."
    fi
}

install_oom_killer() {
    # OOM (Out of Memory) killers prevent system freezes under memory pressure
    # They proactively kill memory-hungry processes before the system becomes unresponsive
    log "INFO" "Installing proactive OOM handling..."
    
    case "$PACKAGE_MANAGER" in
        apt)
            apt install -y earlyoom
            systemctl enable earlyoom
            systemctl start earlyoom
            ;;
        dnf)
            systemctl enable systemd-oomd
            systemctl start systemd-oomd
            ;;
        pacman)
            pacman -S --noconfirm earlyoom
            systemctl enable earlyoom
            systemctl start earlyoom
            ;;
    esac
    
    log "SUCCESS" "OOM killer configured to prevent system freezes."
}

# =====================================================================
# CPU & Multicore Optimization
# =====================================================================

optimize_cpu_performance() {
    # CPU optimization unlocks the full potential of modern multi-core processors
    # These settings prioritize performance over power consumption
    log "INFO" "Optimizing CPU performance and multi-core utilization..."
    
    if [[ "$IS_LAPTOP" == false ]] || [[ "$IS_VM" == true ]]; then
        # Set CPU governor to performance for maximum speed
        if [[ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor ]]; then
            for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
                echo "performance" > "$cpu" 2>/dev/null || true
            done
            log "SUCCESS" "CPU governor set to 'performance' mode."
        fi
    fi
    
    # Install and configure IRQ balancing for multi-core efficiency
    systemctl enable irqbalance
    systemctl start irqbalance
    log "SUCCESS" "IRQ balancing enabled for better multi-core performance."
    
    # Configure tuned for system-wide performance optimization
    if command -v tuned &>/dev/null; then
        if [[ "$IS_LAPTOP" == false ]]; then
            tuned-adm profile latency-performance
            log "SUCCESS" "Tuned profile set to 'latency-performance'."
        else
            tuned-adm profile balanced
            log "SUCCESS" "Tuned profile set to 'balanced' for laptop."
        fi
    fi
}

setup_compiler_optimizations() {
    # Compiler optimizations ensure locally compiled software runs at maximum speed
    # This is particularly important for users who compile from source
    log "INFO" "Setting up aggressive compiler optimizations..."
    
    # Detect CPU architecture for -march=native
    local cpu_arch=$(gcc -march=native -Q --help=target | grep -oP "march=\K\w+")
    
    # Create optimized environment for all users
    cat > /etc/environment << EOF
# Linux Ultimate Tuner - Compiler Optimizations
CFLAGS="-O3 -march=native -mtune=native -fomit-frame-pointer -pipe"
CXXFLAGS="-O3 -march=native -mtune=native -fomit-frame-pointer -pipe"
MAKEFLAGS="-j${CPU_CORES}"
EOF
    
    log "SUCCESS" "Aggressive compiler optimizations configured (CPU: $cpu_arch, Cores: $CPU_CORES)."
}

# =====================================================================
# Network Optimization
# =====================================================================

optimize_network_performance() {
    # Network optimization reduces latency and improves throughput
    # These settings are especially beneficial for high-speed connections
    log "INFO" "Optimizing network performance and DNS resolution..."
    
    # Install and configure local DNS caching
    case "$PACKAGE_MANAGER" in
        apt)
            apt install -y systemd-resolved
            ;;
        dnf)
            dnf install -y systemd-resolved
            ;;
        pacman)
            pacman -S --noconfirm systemd-resolvconf
            ;;
    esac
    
    # Configure systemd-resolved for optimal DNS caching
    backup_file "/etc/systemd/resolved.conf"
    cat > /etc/systemd/resolved.conf << EOF
[Resolve]
DNS=8.8.8.8 1.1.1.1 8.8.4.4 1.0.0.1
FallbackDNS=208.67.222.222 208.67.220.220
Domains=~.
LLMNR=yes
MulticastDNS=yes
DNSSEC=allow-downgrade
DNSOverTLS=opportunistic
Cache=yes
CacheFromLocalhost=yes
DNSStubListener=yes
ReadEtcHosts=yes
EOF
    
    systemctl enable systemd-resolved
    systemctl restart systemd-resolved
    
    # Optimize network interface settings
    if command -v ethtool &>/dev/null; then
        for interface in $(ls /sys/class/net/ | grep -E '^(eth|ens|enp)'); do
            # Disable power saving features that can cause latency
            ethtool -s "$interface" autoneg on 2>/dev/null || true
            log "INFO" "Optimized network interface: $interface"
        done
    fi
    
    log "SUCCESS" "Network optimization completed with local DNS caching."
}

# =====================================================================
# Power Management (Laptop-Specific)
# =====================================================================

optimize_laptop_power() {
    # Laptop power optimization balances performance with battery life
    # This function only runs on detected laptop systems
    if [[ "$IS_LAPTOP" == false ]]; then
        return 0
    fi
    
    log "INFO" "Configuring intelligent power management for laptop..."
    
    case "$PACKAGE_MANAGER" in
        apt)
            apt install -y tlp tlp-rdw auto-cpufreq
            ;;
        dnf)
            dnf install -y tlp tlp-rdw auto-cpufreq
            ;;
        pacman)
            pacman -S --noconfirm tlp auto-cpufreq
            ;;
    esac
    
    # Configure TLP for optimal battery management
    backup_file "/etc/tlp.conf"
    
    # Enable and start power management services
    systemctl enable tlp
    systemctl start tlp
    
    # Enable auto-cpufreq for dynamic CPU scaling
    systemctl enable auto-cpufreq
    systemctl start auto-cpufreq
    
    log "SUCCESS" "Intelligent power management configured (TLP + auto-cpufreq)."
}

# =====================================================================
# Container Environment Cleanup
# =====================================================================

cleanup_containers() {
    # Container cleanup can recover significant disk space
    # Docker and Podman can accumulate gigabytes of unused data over time
    log "INFO" "Cleaning container environments..."
    
    # Docker cleanup
    if command -v docker &>/dev/null; then
        log "INFO" "Cleaning Docker environment..."
        docker system prune -af 2>/dev/null || log "WARNING" "Docker cleanup failed"
        
        # Clean dangling volumes
        docker volume prune -f 2>/dev/null || log "WARNING" "Docker volume cleanup failed"
        
        log "SUCCESS" "Docker environment cleaned."
    fi
    
    # Podman cleanup
    if command -v podman &>/dev/null; then
        log "INFO" "Cleaning Podman environment..."
        podman system prune -af 2>/dev/null || log "WARNING" "Podman cleanup failed"
        
        # Clean dangling volumes
        podman volume prune -f 2>/dev/null || log "WARNING" "Podman volume cleanup failed"
        
        log "SUCCESS" "Podman environment cleaned."
    fi
    
    if ! command -v docker &>/dev/null && ! command -v podman &>/dev/null; then
        log "INFO" "No container runtime detected - skipping container cleanup."
    fi
}

# =====================================================================
# System Monitoring & Health Checks
# =====================================================================

generate_system_health_report() {
    # A comprehensive health report helps users understand their system's current state
    # This information is valuable for troubleshooting and performance monitoring
    log "INFO" "Generating comprehensive system health report..."
    
    local report_file="/tmp/system_health_report_$(date +%Y%m%d_%H%M%S).txt"
    
    cat > "$report_file" << EOF
=====================================================================
Linux Ultimate Tuner - System Health Report
Generated: $(date)
=====================================================================

SYSTEM INFORMATION:
- Hostname: $(hostname)
- OS: $(lsb_release -d 2>/dev/null | cut -f2 || cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)
- Kernel: $(uname -r)
- Architecture: $(uname -m)
- Uptime: $(uptime -p)

HARDWARE CONFIGURATION:
- CPU: $(lscpu | grep "Model name" | sed 's/Model name:\s*//')
- CPU Cores: $CPU_CORES
- Total RAM: ${TOTAL_RAM_GB}GB
- Storage Type: $(if [[ "$HAS_SSD" == true ]]; then echo "SSD"; else echo "HDD"; fi)
- System Type: $(if [[ "$IS_VM" == true ]]; then echo "Virtual Machine"; else echo "Bare Metal"; fi)
- Device Type: $(if [[ "$IS_LAPTOP" == true ]]; then echo "Laptop"; else echo "Desktop"; fi)

CURRENT RESOURCE USAGE:
- CPU Load Average: $(uptime | awk -F'load average:' '{print $2}')
- Memory Usage: $(free -h | grep "Mem:" | awk '{print $3 "/" $2 " (" $3/$2*100 "%)"}')
- Swap Usage: $(free -h | grep "Swap:" | awk '{print $3 "/" $2}')
- Disk Usage: $(df -h / | tail -1 | awk '{print $3 "/" $2 " (" $5 ")"}')

SYSTEM SERVICES STATUS:
$(systemctl list-units --failed --no-legend | head -10)

NETWORK CONFIGURATION:
- Active Interfaces: $(ip -o link show | awk -F': ' '{print $2}' | grep -v lo | tr '\n' ' ')
- DNS Servers: $(systemd-resolve --status | grep "DNS Servers:" | head -1 | cut -d: -f2)

PERFORMANCE OPTIMIZATIONS ACTIVE:
- CPU Governor: $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null || echo "Not available")
- IRQ Balance: $(systemctl is-active irqbalance 2>/dev/null || echo "Not running")
- TRIM Status: $(systemctl is-active fstrim.timer 2>/dev/null || echo "Not applicable")
- TLP Status: $(systemctl is-active tlp 2>/dev/null || echo "Not installed/running")

RECENT LOG ERRORS (Last 24 hours):
$(journalctl --since="24 hours ago" --priority=3 --no-pager -q | tail -5 || echo "No recent errors found")

=====================================================================
Report saved to: $report_file
=====================================================================
EOF
    
    log "SUCCESS" "System health report generated: $report_file"
    
    # Display summary to user
    echo -e "\n${CYAN}=== SYSTEM HEALTH SUMMARY ===${NC}"
    echo -e "CPU Load: $(uptime | awk -F'load average:' '{print $2}')"
    echo -e "Memory: $(free -h | grep "Mem:" | awk '{print $3 "/" $2}')"
    echo -e "Disk: $(df -h / | tail -1 | awk '{print $5 " used"}')"
    echo -e "Uptime: $(uptime -p)"
}

# =====================================================================
# Backup & Snapshot Management
# =====================================================================

setup_system_snapshots() {
    # System snapshots provide the ultimate safety net for aggressive optimizations
    # Different filesystems require different snapshot approaches
    log "INFO" "Configuring automatic system snapshots..."
    
    case "$PACKAGE_MANAGER" in
        apt)
            apt install -y timeshift
            ;;
        dnf)
            dnf install -y timeshift
            ;;
        pacman)
            pacman -S --noconfirm timeshift
            ;;
    esac
    
    # Configure Timeshift based on filesystem type
    if [[ "$FILESYSTEM_TYPE" == "btrfs" ]]; then
        # BTRFS provides native, efficient snapshots
        log "INFO" "Configuring BTRFS snapshots with Timeshift..."
        timeshift --create --comments "Pre-optimization snapshot" --tags D
        
        # Configure automatic snapshots
        cat > /etc/timeshift/timeshift.json << 'EOF'
{
  "backup_device_uuid" : "",
  "parent_device_uuid" : "",
  "do_first_run" : "false",
  "btrfs_mode" : "true",
  "include_btrfs_home_for_backup" : "false",
  "include_btrfs_home_for_restore" : "false",
  "stop_cron_emails" : "true",
  "schedule_monthly" : "false",
  "schedule_weekly" : "true",
  "schedule_daily" : "true",
  "schedule_hourly" : "false",
  "schedule_boot" : "false",
  "count_monthly" : "2",
  "count_weekly" : "3",
  "count_daily" : "5",
  "count_hourly" : "6",
  "count_boot" : "5",
  "snapshot_size" : "0",
  "snapshot_count" : "0"
}
EOF
        
        log "SUCCESS" "BTRFS snapshots configured with automatic scheduling."
    else
        # Use rsync mode for other filesystems
        log "INFO" "Configuring rsync-based snapshots with Timeshift..."
        timeshift --create --comments "Pre-optimization snapshot" --tags D
        
        log "SUCCESS" "Rsync-based snapshots configured."
    fi
    
    # Enable automatic snapshot creation
    systemctl enable cronie 2>/dev/null || systemctl enable cron 2>/dev/null || true
}

create_optimization_snapshot() {
    # Create a specific snapshot before running optimizations
    # This provides a quick restore point if anything goes wrong
    log "INFO" "Creating pre-optimization system snapshot..."
    
    if command -v timeshift &>/dev/null; then
        timeshift --create --comments "Linux Ultimate Tuner - Before optimization $(date)" --tags O
        log "SUCCESS" "Pre-optimization snapshot created successfully."
    else
        log "WARNING" "Timeshift not available - manual backup recommended."
    fi
}

# =====================================================================
# Main Menu System - User Interface
# =====================================================================

display_banner() {
    # An attractive banner improves user experience and provides important information
    clear
    echo -e "${PURPLE}"
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════╗
║                    LINUX ULTIMATE TUNER v2.0                        ║
║                                                                      ║
║         🚀 Advanced System Optimization for Power Users 🚀          ║
║                                                                      ║
║  Maximize Performance • Enhance Stability • Optimize Everything     ║
╚══════════════════════════════════════════════════════════════════════╝
EOF
    echo -e "${NC}"
    
    echo -e "${CYAN}System Information:${NC}"
    echo -e "• Distribution: ${GREEN}$DISTRO${NC} (Package Manager: $PACKAGE_MANAGER)"
    echo -e "• Hardware: ${GREEN}$CPU_CORES cores${NC}, ${GREEN}${TOTAL_RAM_GB}GB RAM${NC}"
    echo -e "• Type: ${GREEN}$(if [[ "$IS_VM" == true ]]; then echo "Virtual Machine"; else echo "Bare Metal"; fi)${NC} • $(if [[ "$IS_LAPTOP" == true ]]; then echo "Laptop"; else echo "Desktop"; fi)"
    echo -e "• Storage: ${GREEN}$(if [[ "$HAS_SSD" == true ]]; then echo "SSD"; else echo "HDD"; fi)${NC} • Filesystem: ${GREEN}$FILESYSTEM_TYPE${NC}"
    echo ""
}

show_main_menu() {
    # The main menu provides clear, organized access to all optimization functions
    # Each option is numbered and color-coded for easy navigation
    echo -e "${WHITE}═══ OPTIMIZATION CATEGORIES ═══${NC}"
    echo -e "${GREEN} 1)${NC} 🧹 Aggressive Disk Cleaning & I/O Optimization"
    echo -e "${GREEN} 2)${NC} 🧠 Advanced Memory Management Optimization"
    echo -e "${GREEN} 3)${NC} 🚀 CPU & Multi-core Performance Boosting"
    echo -e "${GREEN} 4)${NC} 🌐 Network Performance & DNS Optimization"
    echo -e "${GREEN} 5)${NC} 🔋 Intelligent Power Management (Laptops)"
    echo -e "${GREEN} 6)${NC} 🐳 Container Environment Cleanup"
    echo -e "${GREEN} 7)${NC} 💾 System Snapshots & Backup Setup"
    echo -e "${GREEN} 8)${NC} 📊 System Health Report & Monitoring"
    echo -e "${GREEN} 9)${NC} 🔄 Full System Update & Package Management"
    echo ""
    echo -e "${WHITE}═══ EXECUTION OPTIONS ═══${NC}"
    echo -e "${YELLOW}10)${NC} ⚡ Execute ALL Optimizations (Recommended)"
    echo -e "${YELLOW}11)${NC} 🎯 Safe Mode (Conservative optimizations only)"
    echo -e "${YELLOW}12)${NC} 📋 Generate System Report Only"
    echo ""
    echo -e "${RED} 0)${NC} Exit"
    echo ""
    echo -e "${CYAN}Backup Directory:${NC} $BACKUP_DIR"
    echo -e "${CYAN}Log File:${NC} $LOG_FILE"
    echo ""
}

execute_safe_mode() {
    # Safe mode applies only conservative optimizations
    # This is ideal for production systems or cautious users
    log "INFO" "Executing safe mode optimizations..."
    
    create_optimization_snapshot
    update_system
    install_essential_tools
    deep_system_cleanup
    optimize_memory_management
    optimize_network_performance
    generate_system_health_report
    
    log "SUCCESS" "Safe mode optimization completed successfully."
}

execute_full_optimization() {
    # Full optimization applies all available performance enhancements
    # This provides maximum performance gains for enthusiast users
    log "INFO" "Executing full system optimization suite..."
    
    echo -e "${YELLOW}⚠️  WARNING: Full optimization will make aggressive changes to your system!${NC}"
    echo -e "${YELLOW}   A system snapshot will be created for safety.${NC}"
    echo -e "\nProceed with full optimization? (y/N): "
    read -r confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        log "INFO" "Full optimization cancelled by user."
        return 0
    fi
    
    # Execute all optimization modules
    create_optimization_snapshot
    update_system
    install_essential_tools
    deep_system_cleanup
    optimize_disk_io
    disable_file_indexing
    optimize_memory_management
    setup_zram
    install_oom_killer
    optimize_cpu_performance
    setup_compiler_optimizations
    optimize_network_performance
    optimize_laptop_power
    cleanup_containers
    setup_system_snapshots
    generate_system_health_report
    
    log "SUCCESS" "Full system optimization completed successfully!"
    echo ""
    echo -e "${GREEN}🎉 OPTIMIZATION COMPLETE! 🎉${NC}"
    echo -e "${CYAN}Your system has been thoroughly optimized for maximum performance.${NC}"
    echo -e "${CYAN}Reboot recommended to ensure all changes take effect.${NC}"
    echo ""
    echo -e "${YELLOW}To monitor your optimized system, try these commands:${NC}"
    echo -e "• ${WHITE}htop${NC} - Interactive process monitor"
    echo -e "• ${WHITE}btop${NC} - Modern resource monitor"
    echo -e "• ${WHITE}inxi -Fxz${NC} - Detailed system information"
    echo ""
}

# =====================================================================
# Main Program Flow
# =====================================================================

main() {
    # Main function orchestrates the entire optimization process
    # It handles initialization, user interaction, and cleanup
    
    # Initialize logging and safety systems
    create_backup_directory
    check_root
    
    # Perform comprehensive system detection
    log "INFO" "Starting Linux Ultimate Tuner v$VERSION"
    detect_distribution
    detect_system_type
    detect_laptop  
    detect_hardware
    
    # Main program loop
    while true; do
        display_banner
        show_main_menu
        
        echo -e "${WHITE}Select an option [0-12]:${NC} "
        read -r choice
        
        case $choice in
            1)
                log "INFO" "User selected: Disk Cleaning & I/O Optimization"
                create_optimization_snapshot
                deep_system_cleanup
                optimize_disk_io
                disable_file_indexing
                ;;
            2)
                log "INFO" "User selected: Memory Optimization"
                create_optimization_snapshot
                optimize_memory_management
                setup_zram
                install_oom_killer
                ;;
            3)
                log "INFO" "User selected: CPU Optimization"
                create_optimization_snapshot
                optimize_cpu_performance
                setup_compiler_optimizations
                ;;
            4)
                log "INFO" "User selected: Network Optimization"
                create_optimization_snapshot
                optimize_network_performance
                ;;
            5)
                if [[ "$IS_LAPTOP" == true ]]; then
                    log "INFO" "User selected: Power Management"
                    create_optimization_snapshot
                    optimize_laptop_power
                else
                    log "WARNING" "Power management is only applicable to laptop systems."
                fi
                ;;
            6)
                log "INFO" "User selected: Container Cleanup"
                cleanup_containers
                ;;
            7)
                log "INFO" "User selected: Snapshot Setup"
                setup_system_snapshots
                ;;
            8)
                log "INFO" "User selected: System Health Report"
                generate_system_health_report
                ;;
            9)
                log "INFO" "User selected: System Update"
                create_optimization_snapshot
                update_system
                install_essential_tools
                ;;
            10)
                log "INFO" "User selected: Full Optimization"
                execute_full_optimization
                ;;
            11)
                log "INFO" "User selected: Safe Mode"
                execute_safe_mode
                ;;
            12)
                log "INFO" "User selected: Report Only"
                generate_system_health_report
                ;;
            0)
                log "INFO" "User selected: Exit"
                echo -e "\n${GREEN}Thank you for using Linux Ultimate Tuner!${NC}"
                echo -e "${CYAN}Backup location: $BACKUP_DIR${NC}"
                echo -e "${CYAN}Log file: $LOG_FILE${NC}"
                echo -e "${YELLOW}Remember to reboot if you applied system optimizations.${NC}\n"
                exit 0
                ;;
            *)
                log "ERROR" "Invalid option selected: $choice"
                echo -e "${RED}Invalid option. Please select 0-12.${NC}"
                sleep 2
                ;;
        esac
        
        echo ""
        echo -e "${GREEN}Operation completed!${NC} Press Enter to continue..."
        read -r
    done
}

# =====================================================================
# Script Entry Point
# =====================================================================

# Trap signals for clean exit
trap 'log "ERROR" "Script interrupted by user"; exit 1' INT TERM

# Verify script is being run with proper permissions and environment
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Script is being executed directly (not sourced)
    main "$@"
else
    log "ERROR" "This script should be executed, not sourced."
    exit 1
fi

# =====================================================================
# END OF LINUX ULTIMATE TUNER
# =====================================================================

# Usage Instructions:
# 
# 1. Save this script as Linux_Ultimate_Tuner.sh
# 2. Make it executable: chmod +x Linux_Ultimate_Tuner.sh  
# 3. Run with root privileges: sudo ./Linux_Ultimate_Tuner.sh
#
# The script will:
# - Automatically detect your hardware and distribution
# - Create timestamped backups of all modified files
# - Provide a menu-driven interface for selective optimization
# - Generate comprehensive logs and system health reports
# - Create system snapshots for easy restoration if needed
#
# For maximum safety, always run option 7 (System Snapshots) first,
# then use option 11 (Safe Mode) for conservative optimization, or
# option 10 (Full Optimization) for maximum performance gains.
#
# All optimizations can be reverted using the backup files created
# in the timestamped backup directory shown in the interface.